#!/bin/bash
PROGNAME=$(basename $0)
VERSION="$Date: 2017/04/27 05:19:29 $"

# Executable file extension:
EXE=".exe"

function help()
{
echo "
$PROGNAME - Creates Makefile for all C source files in current directory.
Existing Makefile is saved in backup file if either not generated by this
program or modified by hand since it was generated.

Syntax:

	make-makefile [-h] [--help] [SRC.c] ...

Options:
   
   --help | -h    Only displays this help and exits.

If one or more SRC.c source files are given, displays on stdout the targets that
would be generated for that source, but does not create the Makefile.

If any of the .c files of the programs or modules involved in a target contains
the "LINKING_OPTIONS" marker, all the options listed up to the end of the line
are added to the compilation command. Example:

    /*
     * COMPILATION_OPTIONS -iconv
     */

If a file named "Makefile-include.txt" is present in the directory, it is
included.

Rationale and more info: http://www.icosaedro.it/c-modules.html

Author: Umberto Salsi <salsi@icosaedro.it>
Version: $VERSION
"
}


# File to include (optional):
MAKEFILE_INCLUDE=Makefile-include.txt

# Preamble of the checksum marker added to the end of the generated Makefile
# to later detect for content changes.
CHECKSUM_MARKER="# Checksum of the original file:"

# Returns the checksum for a text file.
# $1: Text file.
function checksum_calculate()
{
	cat $1 | tr -d '\r' | grep -v "^$CHECKSUM_MARKER [0-9]\\+\$" | cksum | (read cksum x; echo $cksum)
}


# Appends a checksum line to a text file.
# $1: File to mark with the checksum.
function checksum_append()
{
	local cksum
	cksum=$(checksum_calculate $1)
	echo "$CHECKSUM_MARKER $cksum" >> $1
}


# Returns true if the file contains a valid checksum marker.
# $1: File to check.
function checksum_good()
{
	local old_cksum cur_cksum
	[ -r $1 ] || return 1
	old_cksum=$(cat $1 | tr -d '\r' | grep "^$CHECKSUM_MARKER [0-9]\\+\$" | tail -n 1 | sed "s/^$CHECKSUM_MARKER //")
	cur_cksum=$(checksum_calculate $1)
	[ "x$old_cksum" = "x$cur_cksum" ]
}


# Normalize path as a string, no disk access. Removes useless "/./", removes
# multiple slash "///", resolves where possible parent directory references
# "/../".
# Sends the result to stdout.
#
# The resulting normalized path may have only one of the following formats:
# 
# 1. Absolute path starting with "/", possibly followed by names separated
#    by a single "/". Examples: "/", "/NAME", "/NAME/NAME".
# 
# 2. The current directory ".".
# 
# 3. One or more parent directories ".." possibly followed by zero or more
#    names. Examples: "..", "../..", "../NAME", "../../NAME/NAME".
# 
# 4. One or more names separated by "/". Examples: "NAME", "NAME/NAME".
# 
# The normalized empty string is the current directory ".".
# 
# Here NAME is any sequence of bytes excluding "/" and NUL; "." and ".." are
# not names.
#
# File path normalization is required by this program to check if a file has
# been already processed, avoid infinite loops, avoid wasting time, works with
# files that do not exist yet, and allows to generate a cleaner output and with
# only relative paths.
# Test code available at the end of this script.
#
# From an idea of S. Chauveau,
# http://www.linuxjournal.com/content/normalizing-path-names-bash Fri, 09/04/2009
# $1: path to normalize.
function normalize_path()
{
	local DIR i nb OLD_IFS PREFIX part j
	declare -a PARTS RESULT
	DIR="$1"

	# Split the path into parts using / as separator:
	OLD_IFS="$IFS" ; IFS="/" ; PARTS=($DIR) ; IFS="$OLD_IFS"

	# Detect an absolute path by checking the 1st character:
	if [ "${DIR:0:1}" == "/" ] ; then PREFIX="/"; else PREFIX=""; fi

	# Scan each part one at a time copying good parts to $KEEP[j].
	j=0 # next available index to $KEEP
	nb=${#PARTS[*]}
	for ((i=0; i<nb; i++)) ; do
		part="${PARTS[i]}"
		if [ "$part" = "." -o "$part" = "" ] ; then
			# Remove "." and empty part.
			continue
		elif [ "$part" = ".." ]; then
			# Drop ".." if the left part is already the root:
			if [ $j -eq 0 ] && [ "$PREFIX" = "/" ]; then
				continue
			fi
			# ...or the left part is a named part (NOT "..") to drop too:
			if [ $j -gt 0 ] && [ "${KEEP[j-1]}" != ".." ]; then
				# drop left named part:
				unset KEEP[j-1]
				j=$((j-1))
				continue
			fi
		fi
		KEEP[j]="$part"
		j=$((j+1))
	done

	# and finally reconstruct the path
	IFS='/' ; DIR="$PREFIX${KEEP[*]}" ; IFS="$OLD_IFS"
	if [ -z "$DIR" ]; then
		# Relative path and no parts remaining: either empty path or only back
		# and forth like "a/../b/.." that bring nowhere. The current directory
		# "." is the best translation of this concept of "stay there":
		DIR="."
	fi
	echo "$DIR"
}


# Returns a list of modules included by the given file, each module with
# path but without extension.
# $1: source file.
# Return: list of modules directly included by this source file, with path
# but without extension.
function list_includes()
{
	grep "^#include[ \\t]\\+\"" $@ | sed -e "s/^[^\"]*\"//" -e "s/\\.h\".*//g"
}

# Warn above this recursion limit:
WARN_RECURSION=20
# Fatal error above this recursion limit:
ERROR_RECURSION=100
recursion_level=0


# Increases recursion level and error if too deep.
function entering()
{
	recursion_level=$((recursion_level + 1))
	if [ $recursion_level -ge $ERROR_RECURSION ]; then
		echo "$PROGNAME: ERROR: recursion safeguard limit $ERROR_RECURSION reached." >&2
		recursion_level=$((recursion_level-1))
		return 1
	elif [ $recursion_level -ge $WARN_RECURSION ]; then
		echo "$PROGNAME: Warning: recursion level $recursion_level reached." >&2
		return 0
	else
		return 0
	fi
}

# Decreases the recursion level.
function exiting()
{
	recursion_level=$((recursion_level - 1))
	if [ $recursion_level -lt 0 ]; then
		echo "$PROGNAME: ERROR: recursion negative!?" >&2
		exit 1
	fi
}


# Recursively adds a source and its dependencies to global $objs, each entry
# with path but without extension, separated by at least one space, no duplicates.
# Both the .c and the .h source files are examined recursively.
# $1: source file name without extension.
# $2: if "yes" this is the first recursive call over a module or it is a linking,
# then we must recurse on .c too. Set to "no" for deeper recursion on module
# compilation, so that only .h are scanned because implementations .c do not care.
# $3: if "yes" we are collection all the dependencies for linking, then we must
# recurse on any .h and .c at any deep and collect all the involved modules. Set
# to "no" for single module compilation.
function recurse()
{
	local b recurseOnC isLinking base srcs deps i
	b=$1
	recurseOnC=$2
	isLinking=$3
	base=$(dirname $b)
	if [ $base = "." ]; then
		base=""
	else
		base="$base/"
	fi
	if [[ "$objs" == *" $b "* ]]; then
		return
	fi
	entering || return
	objs="$objs $b "
	if [ $recurseOnC = yes ]; then
		srcs="$b.c"
	else
		srcs=""
	fi
	[ -f $b.h ] && srcs="$srcs $b.h"
	deps=$( list_includes $srcs )
	if [ -z "$deps" ]; then
		exiting
		return
	fi
	for i in $deps; do
		i=$(normalize_path $base$i)
		if [ ! -f $i.c ]; then
			echo "$b: cannot find $i" >&2
		else
			recurse $i $isLinking $isLinking
		fi
	done
	exiting
}


# Sends to stdout the Makefile targets that build .o and .exe. For library
# modules (both .h and .c do exit) only the .o is generated. For programs
# (only .c does exit) the executable .exe is generated too.
# Shares the global variable $objs along with the recurse() function where
# the file names without extension of the recursively examined source files
# are collected.
# $1: source file name without extension.
function compile()
{
	local b f deps h
	b=$1

	# Compile module.
	# ===============
	# Dependencies are: .h and .c of the module, any .h included from these and
	# any other .h included by these latter .h (recursively). Note that the
	# implementations .c of the other modules are not scanned, only their
	# interfaces are. Here a program is nothing more than a module without
	# interface .h, its interface being the implicit "main()" function.
	###echo "--> $b.o" >&2
	# list of source file names without extension separated by space
	objs=""
	recurse $b yes no
	if [ $recursion_level -ne 0 ]; then
		echo "$PROGNAME: unbalanced calls to entering/exiting function" >&2
		exit 1
	fi
	deps=$(echo $objs | tr ' ' '\n' | grep -v "^$" | sort | uniq )
	echo
	echo -n "$b.o: $b.c"
	[ -f $b.h ] && echo -n " $b.h"
	for f in $deps; do
		[ $f = $b ] && continue
		echo -n " $f.h"
	done
	echo
	echo -e "\t\$(CC) \$(CFLAGS) -c $b.c -o $b.o"

	if [ -f $b.h ]; then
		return
	fi

	# It's a program: linking.
	# ========================
	# Dependencies are: .c and the .o of any module included directly and
	# indirectly, including each implementation and its dependencies recursively.
	###echo "--> $b" >&2
	# list of source file names without extension separated by space
	objs=""
	recurse $b yes yes
	if [ $recursion_level -ne 0 ]; then
		echo "$PROGNAME: unbalanced calls to entering/exiting function" >&2
		exit 1
	fi
	deps=$(echo $objs | tr ' ' '\n' | grep -v "^$" | sort | uniq )
	echo
	echo -n "$b$EXE:"
	o=""
	for f in $deps; do
		o="$o $f.o"
	done
	echo "$o"
	echo -ne "\t\$(CC) \$(CFLAGS) -o $b$EXE $o \$(LIBS) "
	# Add linker options annotated in the .c sources.
	for f in $deps; do
		grep LINKER_OPTIONS $f.c
	done \
	| sed -e "s/.*LINKER_OPTIONS//" -e "s/^[ \\t]\\+//" -e "s/[ \\t\\r]\\+\$//" \
	| grep -v "^\$" | sort | uniq | tr '\n' ' '
	echo
}


# Sends to stdout the Makefile content to build programs and libraries
# found in this directory. Also generates the usual 'all' and 'clean' targets
# that recursively operates on subdirectories.
function create_makefile()
{
	local c b all
	echo "# This file generated by $PROGNAME, do not edit!"
	echo "# Create Makefile-include.txt instead for your customizations."
	echo "CC := gcc"
	echo "CFLAGS := -Wall -Werror -g -fmax-errors=99 -Wuninitialized -Wmissing-prototypes -Wredundant-decls"
	echo "LIBS :="

	# "all" target compiles all .c into .o and programs in this dir:
	###echo "--> all" >&2
	programs=""
	echo
	echo ".PHONY: all"
	echo "all:"
	# Recursively build sub-dirs first for which a Makefile is already available:
	find . -maxdepth 1 -type d \! -name CVS \! -name . \
	| while read subdir; do
		if [ -f $subdir/Makefile ]; then
			echo -e "\tcd $subdir && make all"
		fi
	done
	# Buils .o and .exe in this dir:
	all=""
	for c in $(ls *.c 2>/dev/null); do
		b=${c%.c}
		if [ -f $b.h ]; then
			all="$all $b.o" # builds .o
		else
			programs="$programs $b"
			all="$all $b$EXE" # builds .exe
		fi
	done
	if [ ! -z "$all" ]; then
		echo -e "\tmake $all"
	fi

	echo
	[ -f $MAKEFILE_INCLUDE ] || echo -n "#"
	echo "include $MAKEFILE_INCLUDE"
	
	# "test" target starts all the programs in this dir:
	if [ ! -z "$programs" ]; then
		###echo "--> test" >&2
		echo
		echo ".PHONY: test"
		echo -n "test:"
		for b in $programs; do
			echo -n " $b$EXE"
		done
		echo
		for b in $programs; do
			echo -e "\t./$b$EXE"
		done
		echo
	fi

	# "clean" removes objs, exe, core dumps:
	###echo "--> clean" >&2
	echo
	echo ".PHONY: clean"
	echo "clean:"
	echo -ne "\trm -f *.o *.exe *.stackdump"
	for b in $programs; do
		echo -ne " $b"
	done
	echo
	# Recursively clean sub-dirs first for which a Makefile is already available:
	find . -maxdepth 1 -type d \! -name CVS \! -name . \
	| while read subdir; do
		if [ -f $subdir/Makefile ]; then
			echo -e "\tcd $subdir && make clean"
		fi
	done
	
	# For each .c, create target to build .o and, if program, the .exe too:
	for c in $(ls *.c 2>/dev/null); do
		b=${c%.c}
		compile $b
	done
	echo
}

main()
{
	local create_makefile
	create_makefile=yes
	while [ $# -gt 0 ]; do
		case $1 in
		-h|--help) help; exit;;
		-*) "$PROGNAME: ERROR: unknown option $1, try --help" >&2; exit 1;;
		*.c)
			compile ${1%.c}
			create_makefile=no
			;;
		*) "$PROGNAME: ERROR: unexpected argument $1, try --help" >&2; exit 1;;
		esac
		shift
	done

	# Create new Makefile in tmp file:
	[ $create_makefile = no ] && exit
	create_makefile > Makefile-tmp
	checksum_append Makefile-tmp

	# Save a backup of the existing Makefile is not generated or modified:
	if [ -f Makefile ]; then
		if ! checksum_good Makefile; then
			cp Makefile Makefile-$(date +%s).bak || exit 1
		fi
	fi

	# Ok, create or overwrite Makefile:
	mv Makefile-tmp Makefile
}

main "$@" ; exit


############ TEST CODE FOLLOWS - IGNORE #################

# Test code for the file path normalization function.
# $1: path to normalize.
# $2: expected normalized path.
function normalize_path_test()
{
	local p
	p=$(normalize_path $1)
	if [ "$p" != "$2" ]; then
		echo "Test failed:"
		echo "    in:  $1"
		echo "    got: $p"
		echo "    exp: $2"
	fi
}

# Test code for the file path normalization function.
function normalize_path_tests()
{
	normalize_path_test "" "."
	normalize_path_test "/" "/"
	normalize_path_test "." "."
	normalize_path_test ".." ".."
	normalize_path_test "a///b///" "a/b"
	normalize_path_test "a/" "a"
	normalize_path_test "/a" "/a"
	normalize_path_test "a" "a"
	normalize_path_test "./a" "a"
	normalize_path_test "/./a" "/a"
	normalize_path_test "a/b/" "a/b"
	normalize_path_test "a/./b/./." "a/b"
	normalize_path_test "a/../b" "b"
	normalize_path_test "a/b/../../c" "c"
	normalize_path_test "../aa" "../aa"
	normalize_path_test "../../aa" "../../aa"
	normalize_path_test "/../a" "/a" # in fact "ls /../tmp" works
}

#normalize_path_tests; exit